// src/main.rs
mod message_handler;
mod models;
mod token_analysis;
mod websocket;
mod db;

use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080";
    let listener = TcpListener::bind(addr).await.expect("Failed to bind");
    println!("WebSocket server listening on ws://{}", addr);

    while let Ok((stream, addr)) = listener.accept().await {
        println!("New client connected: {}", addr);
        tokio::spawn(websocket::handle_connection(stream));
    }
}




// src/message_handler.rs
use crate::models::TokenResponse;
use crate::token_analysis::{TokenFilter, TokenMetrics};

pub fn handle_token_message(message: &str) {
    match serde_json::from_str::<TokenResponse>(message) {
        Ok(token_response) => {
            let filter = TokenFilter::default();

            for token in token_response.data.iter().filter(|t| filter.meets_criteria(t)) {
                let metrics = TokenMetrics::from_token(token);
                print_token_metrics(&metrics);
            }
        }
        Err(e) => {
            eprintln!("Failed to parse message: {}", e);
        }
    }
}

fn print_token_metrics(metrics: &TokenMetrics) {
    println!("ðŸš€ Trending Token Found:");
    println!("Name: {} ({})", metrics.name, metrics.symbol);
    println!("Price: ${:.8}", metrics.price_usd.unwrap_or_default());
    println!("Market Cap: ${:.2}", metrics.market_cap);
    println!("Holders: {}", metrics.holders);
    println!("Top Holders %: {:.2}%", metrics.top_holders_perc);
    println!("Volume: ${:.2}", metrics.volume);
    println!("Volume/MCap: {:.3}", metrics.volume_mcap_ratio);
    println!("Buy/Sell Ratio: {:.2}", metrics.buy_sell_ratio);
    println!("Age (hours): {:.2}", metrics.age_hours);
    println!("---");
}

// src/models.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct TokenResponse {
    #[serde(rename = "type")]
    pub message_type: String,
    pub data: Vec<TokenData>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TokenData {
    pub attributes: TokenAttributes,
    pub id: String,
    #[serde(rename = "type")]
    pub data_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TokenAttributes {
    pub address: String,
    pub audit: TokenAudit,
    pub buys_count: i64,
    pub created_timestamp: i64,
    pub cur_liq: Liquidity,
    #[serde(default)]
    pub dev_holding_perc: Option<f64>,
    pub dex_i: i64,
    #[serde(default)]
    pub fdv: f64,
    pub holders_count: i64,
    pub name: String,
    #[serde(default)]
    pub price_usd: Option<f64>,
    pub symbol: String,
    pub volume: f64,
    #[serde(default)]
    pub socials: Option<Socials>,
    pub sells_count: Option<i64>,
    pub pooled_sol: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TokenAudit {
    pub freeze_authority: bool,
    #[serde(with = "string_or_float")]
    pub lp_burned_perc: f64,
    pub mint_authority: bool,
    #[serde(with = "string_or_float")]
    pub top_holders_perc: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Liquidity {
    #[serde(with = "string_or_float")]
    pub quote: f64,
    pub usd: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Socials {
    #[serde(default)]
    pub medium: Option<String>,
    #[serde(default)]
    pub reddit: Option<String>,
    #[serde(default)]
    pub telegram: Option<String>,
    #[serde(default)]
    pub twitter: Option<String>,
    #[serde(default)]
    pub website: Option<String>,
}

// Custom serializer/deserializer for handling both string and float values
mod string_or_float {
    use serde::{self, Deserialize, Deserializer, Serializer};
    use std::str::FromStr;

    pub fn serialize<S>(value: &f64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&value.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<f64, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum StringOrFloat {
            String(String),
            Float(f64),
        }

        match StringOrFloat::deserialize(deserializer)? {
            StringOrFloat::String(s) => f64::from_str(&s).map_err(serde::de::Error::custom),
            StringOrFloat::Float(f) => Ok(f),
        }
    }
}




use crate::models::{TokenAttributes, TokenData};

// src/token_analysis.rs
pub struct TokenFilter {
    min_market_cap: f64,
    max_market_cap: f64,
    max_top_holders_perc: f64,
    min_buy_sell_ratio: f64,
    min_volume: f64,
    min_pooled_sol: f64,
}

impl Default for TokenFilter {
    fn default() -> Self {
        Self {
            min_market_cap: 40000.0,
            max_market_cap: 500000.0,
            max_top_holders_perc: 25.0,
            min_buy_sell_ratio: 1.2,
            min_volume: 5000.0,
            min_pooled_sol: 20.0,
        }
    }
}

impl TokenFilter {
    pub fn has_positive_momentum(&self, attributes: &TokenAttributes) -> bool {
        let buy_to_sell_ratio = attributes.buys_count as f64 /
            (attributes.sells_count.unwrap_or(1) as f64);
        let volume_to_mcap_ratio = attributes.volume / attributes.fdv;

        buy_to_sell_ratio >= self.min_buy_sell_ratio &&
            attributes.volume >= self.min_volume &&
            attributes.pooled_sol >= self.min_pooled_sol &&
            volume_to_mcap_ratio > 0.1
    }

    pub fn meets_criteria(&self, token: &TokenData) -> bool {
        let attrs = &token.attributes;

        // Basic checks
        if attrs.fdv < self.min_market_cap || attrs.fdv > self.max_market_cap {
            return false;
        }

        // Check top holders percentage
        if attrs.audit.top_holders_perc > self.max_top_holders_perc {
            return false;
        }

        // Check for Twitter presence
        if attrs.socials.as_ref()
            .and_then(|s| s.twitter.as_ref())
            .is_none() {
            return false;
        }

        self.has_positive_momentum(attrs)
    }
}

#[derive(Debug)]
pub struct TokenMetrics {
    pub name: String,
    pub symbol: String,
    pub price_usd: Option<f64>,
    pub market_cap: f64,
    pub holders: i64,
    pub top_holders_perc: f64,
    pub volume: f64,
    pub volume_mcap_ratio: f64,
    pub buy_sell_ratio: f64,
    pub age_hours: f64,
}

impl TokenMetrics {
    pub fn from_token(token: &TokenData) -> Self {
        let attrs = &token.attributes;
        let current_timestamp = chrono::Utc::now().timestamp();
        let age_hours = (current_timestamp - attrs.created_timestamp) as f64 / 3600.0;

        Self {
            name: attrs.name.clone(),
            symbol: attrs.symbol.clone(),
            price_usd: attrs.price_usd,
            market_cap: attrs.fdv,
            holders: attrs.holders_count,
            top_holders_perc: attrs.audit.top_holders_perc,
            volume: attrs.volume,
            volume_mcap_ratio: attrs.volume / attrs.fdv,
            buy_sell_ratio: attrs.buys_count as f64 /
                (attrs.sells_count.unwrap_or(1) as f64),
            age_hours,
        }
    }
}



// src/websocket.rs
use crate::message_handler::handle_token_message;
use futures_util::StreamExt;
use tokio::net::TcpStream;
use tokio_tungstenite::tungstenite::Message;
use tokio_tungstenite::{accept_async, WebSocketStream};

pub async fn handle_connection(stream: TcpStream) {
    let ws_stream = match accept_async(stream).await {
        Ok(ws) => ws,
        Err(e) => {
            eprintln!("Failed to accept websocket connection: {}", e);
            return;
        }
    };

    process_websocket(ws_stream).await;
}

async fn process_websocket(ws_stream: WebSocketStream<TcpStream>) {
    let (_write, mut read) = ws_stream.split();

    while let Some(message) = read.next().await {
        match message {
            Ok(msg) => {
                if let Message::Text(text) = msg {
                    handle_token_message(&text);
                }
            }
            Err(e) => {
                eprintln!("Error receiving message: {}", e);
                break;
            }
        }
    }
}


